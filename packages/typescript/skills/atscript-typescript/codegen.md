# Code Generation — @atscript/typescript

> How `.as` files are transformed into `.d.ts` type declarations and `.js` runtime modules.

## Overview

Each `.as` file produces two outputs:

| Output | Generated By | Contains |
|--------|-------------|----------|
| `*.as.d.ts` | `npx asc -f dts` or build tool | TypeScript type declarations — interfaces become `declare class` with static type/metadata/validator |
| `*.as.js` | Build tool (unplugin-atscript) | Runtime module — classes with full type definitions, metadata maps, and validator factories |

## `.d.ts` Output

The TypeScript declaration file makes `.as` types importable with full IntelliSense:

```as
// user.as
@meta.label "User"
export interface User {
  name: string
  age: number
  email?: string
}

export type Status = "active" | "inactive"
```

Generates `user.as.d.ts`:

```ts
import type {
  TAtscriptTypeObject, TAtscriptAnnotatedType,
  TMetadataMap, Validator, TValidatorOptions
} from "@atscript/typescript/utils"

export declare class User {
  name: string
  age: number
  email?: string
  static __is_atscript_annotated_type: true
  static type: TAtscriptTypeObject<keyof User, User>
  static metadata: TMetadataMap<AtscriptMetadata>
  static validator: (opts?: Partial<TValidatorOptions>) => Validator<typeof User>
  static toJsonSchema: () => any
  /** When exampleData is disabled (default), marked @deprecated + optional */
  static toExampleData?: () => any
}

export type Status = "active" | "inactive"
declare namespace Status {
  const __is_atscript_annotated_type: true
  const type: TAtscriptTypeComplex<Status>
  const metadata: TMetadataMap<AtscriptMetadata>
  const validator: (opts?: Partial<TValidatorOptions>) => Validator<typeof Status>
  const toJsonSchema: () => any
  const toExampleData: (() => any) | undefined
}
```

Key points:
- **Interfaces** become `declare class` — so they work both as types and runtime values
- **Types** become a `type` alias + a companion `namespace` with runtime statics
- Each has `type`, `metadata`, `validator()`, `toJsonSchema()`, and `toExampleData()` statics
- `toExampleData` is always optional in `.d.ts`. When `exampleData: true`, it's rendered without deprecation; when disabled, it's marked `@deprecated`

## `.js` Output

The JS module creates actual classes with runtime type definitions and metadata:

- Uses `defineAnnotatedType` (aliased as `$`) to build the type tree
- Populates metadata maps with all annotation values
- Wires up `validator()` and `toJsonSchema()` methods
- When `exampleData: true`, adds `toExampleData()` that calls `createDataFromAnnotatedType(this, { mode: 'example' })` (aliased as `$e`)
- When `jsonSchema: false` (default), `toJsonSchema()` calls `throwFeatureDisabled()` (aliased as `$d`) instead of inlining the error message

You don't normally read or modify generated JS — the build tool handles it.

## `atscript.d.ts` — Global Type Declarations

Running `npx asc -f dts` also generates `atscript.d.ts` in your project root:

```ts
export {}

declare global {
  interface AtscriptMetadata {
    'meta.label': string
    'meta.required': { message?: string } | true
    'expect.minLength': { length: number; message?: string }
    // ... all annotations used in your project
  }
  type AtscriptPrimitiveTags = "string" | "number" | "boolean" | "null"
}
```

This file is **auto-generated** based on the annotations actually used across all your `.as` files. It enables:

- Type-safe `metadata.get('meta.label')` calls — TypeScript knows the return type
- Autocompletion for annotation keys
- Correct types for primitive tags

**Important**: Re-run `npx asc -f dts` after adding new annotations to your config. The `atscript.d.ts` file should be committed to your repository.

## Import Paths

Generated files use these import paths:

| Import | Source |
|--------|--------|
| `@atscript/typescript/utils` | Runtime utilities (used by generated `.js` files) |

When importing from `.as` files in your TypeScript code:

```ts
// Import the generated interface — works as both a type and a runtime value
import { User } from './models/user.as'

// Use as a type
function greet(user: User) { ... }

// Use as a runtime value (has metadata, validator, etc.)
User.metadata.get('meta.label')  // "User"
User.validator().validate(data)
```
