import {
  AtscriptDoc,
  isArray,
  isConst,
  isGroup,
  isInterface,
  isPrimitive,
  isRef,
  isStructure,
  SemanticAnnotateNode,
  SemanticArrayNode,
  SemanticInterfaceNode,
  SemanticNode,
  SemanticPropNode,
  SemanticRefNode,
  SemanticStructureNode,
  SemanticTypeNode,
  TPrimitiveTypeDef,
} from '@atscript/core'
import { BaseRenderer } from './base-renderer'
import { escapeQuotes, wrapProp } from './utils'
import { type TTsPluginOptions, resolveJsonSchemaMode } from '../plugin'

export class TypeRenderer extends BaseRenderer {
  constructor(
    doc: AtscriptDoc,
    private opts?: TTsPluginOptions
  ) {
    super(doc)
  }

  pre() {
    this.writeln('// prettier-ignore-start')
    this.writeln('/* eslint-disable */')
    this.writeln(`/// <reference path="./${this.doc.name}" />`)
    this.writeln('/**')
    this.writeln(' * ðŸª„ This file was generated by Atscript')
    this.writeln(' * Do not edit this file!')
    this.writeln(' */')
    this.writeln()
    this.writeln(
      'import type { TAtscriptTypeObject, TAtscriptTypeComplex, TAtscriptTypeFinal, TAtscriptTypeArray, TAtscriptAnnotatedType, TMetadataMap, Validator, TValidatorOptions } from "@atscript/typescript/utils"'
    )
  }

  post() {
    this.writeln('// prettier-ignore-end')
  }

  renderTypeDefString(def?: SemanticNode) {
    const newThis = new TypeRenderer(this.doc, this.opts)
    newThis.renderTypeDef(def)
    return newThis.toString()
  }

  renderTypeDef(def?: SemanticNode) {
    if (!def) {
      this.write('unknown')
      return
    }
    if (isStructure(def)) {
      return this.renderStructure(def)
    }
    if (isGroup(def)) {
      const tuple = def.entity === 'tuple'
      const operator = tuple ? ', ' : ` ${def.op!} `
      const children = def.unwrap()
      const hasSubgroup = !tuple && children.some(c => c.entity === 'group')
      this.write(tuple ? '[' : hasSubgroup ? '(' : '')
      this.renderTypeDef(def.first)
      for (const child of children.slice(1)) {
        this.write(operator)
        this.renderTypeDef(child)
      }
      return this.write(tuple ? ']' : hasSubgroup ? ')' : '')
    }
    if (isConst(def)) {
      const name =
        def.token('identifier')?.type === 'number' ? def.id! : `"${escapeQuotes(def.id!)}"`
      return this.write(name)
    }
    if (isRef(def)) {
      const node = def as SemanticRefNode
      const unwound = this.doc.unwindType(node.id!, node.chain)
      if (isPrimitive(unwound?.def)) {
        this.write(renderPrimitiveTypeDef(unwound.def.config.type))
        if (node.hasChain) {
          this.write(` /* ${node.chain.map(c => c.text).join('.')} */`)
        }
        return
      }
      let name = node.id!
      for (const c of node.chain) {
        name += `["${escapeQuotes(c.text)}"]`
      }
      return this.write(name)
    }
    if (isArray(def)) {
      const node = def as SemanticArrayNode
      const def2 = node.getDefinition()
      const isGrp = def2?.entity === 'group'
      if (isGrp) {
        this.write('(')
      }
      this.renderTypeDef(def2)
      if (isGrp) {
        this.write(')')
      }
      return this.write('[]')
    }
  }

  renderStructure(struct: SemanticStructureNode, asClass?: string) {
    this.blockln('{}')
    // let propsList = ''
    const patterns = [] as SemanticPropNode[]
    const propsDefs = new Set<string>()

    for (const prop of Array.from(struct.props.values())) {
      // propsList += (propsList ? ' | ' : '') + `"${escapeQuotes(prop.id!)}"`
      if (prop.token('identifier')?.pattern) {
        patterns.push(prop)
        continue
      }
      const optional = !!prop.token('optional')
      this.write(wrapProp(prop.id!), optional ? '?' : '', ': ')
      const renderedDef = this.renderTypeDefString(prop.getDefinition())
      propsDefs.add(renderedDef)
      renderedDef.split('\n').forEach(l => this.writeln(l))
    }
    if (patterns.length) {
      this.write(`[key: string]: `)
      if (patterns.length > 0) {
        for (const prop of patterns) {
          propsDefs.add(this.renderTypeDefString(prop.getDefinition()))
        }
        const defs = Array.from(propsDefs)
        if (defs.length > 1) {
          this.indent()
          for (const def of defs) {
            this.writeln()
            this.write('| ')
            def.split('\n').forEach(l => this.write(l.trim()))
          }
          this.unindent()
          this.writeln()
        } else {
          defs[0].split('\n').forEach(l => this.writeln(l))
        }
      }
    }
    if (asClass) {
      this.writeln('static __is_atscript_annotated_type: true')
      this.writeln(`static type: TAtscriptTypeObject<keyof ${asClass}, ${asClass}>`)
      this.writeln(`static metadata: TMetadataMap<AtscriptMetadata>`)
      this.writeln(
        `static validator: (opts?: Partial<TValidatorOptions>) => Validator<typeof ${asClass}>`
      )
      if (resolveJsonSchemaMode(this.opts) === false) {
        this.writeln("/** @deprecated JSON Schema support is disabled. Calling this method will throw a runtime error. To enable, set `jsonSchema: 'lazy'` or `jsonSchema: 'bundle'` in tsPlugin options, or add `@emit.jsonSchema` annotation to individual interfaces. */")
      }
      this.writeln('static toJsonSchema: () => any')
    }
    this.pop()
  }

  renderInterface(node: SemanticInterfaceNode) {
    this.writeln()
    const exported = node.token('export')?.text === 'export'
    this.renderJsDoc(node)
    this.write(exported ? 'export declare ' : 'declare ')
    this.write(`class ${node.id!} `)
    const struct = node.getDefinition()
    if (struct?.entity === 'structure') {
      this.renderStructure(struct as SemanticStructureNode, node.id!)
    } else {
      this.writeln('{}')
    }
    this.writeln()
    const nsPrefix = exported ? 'export declare' : 'declare'
    this.write(`${nsPrefix} namespace ${node.id!} `)
    this.blockln('{}')
    this.writeln(`type DataType = ${node.id!}`)
    this.popln()
    this.writeln()
  }

  renderType(node: SemanticTypeNode) {
    this.writeln()
    const exported = node.token('export')?.text === 'export'
    this.renderJsDoc(node)
    this.write(exported ? 'export ' : 'declare ')
    this.write(`type ${node.id!} = `)
    this.renderTypeDef(node.getDefinition())
    this.writeln()
    this.renderTypeNamespace(node)
  }

  renderAnnotate(node: SemanticAnnotateNode) {
    // Only render non-mutating annotate (with alias)
    if (node.isMutating) {
      return
    }
    const targetName = node.targetName
    this.writeln()
    const exported = node.token('export')?.text === 'export'
    this.renderJsDoc(node)

    if (this.isTypeTarget(targetName)) {
      // Target is a type â€” render as type alias + namespace
      this.write(exported ? 'export ' : 'declare ')
      this.write(`type ${node.id!} = ${targetName}`)
      this.writeln()
      const unwound = this.doc.unwindType(targetName)
      this.renderTypeNamespaceFor(node.id!, unwound?.def)
    } else {
      // Target is an interface â€” render as class extends
      this.write(exported ? 'export declare ' : 'declare ')
      this.writeln(`class ${node.id!} extends ${targetName} {}`)
      const nsPrefix = exported ? 'export declare' : 'declare'
      this.write(`${nsPrefix} namespace ${node.id!} `)
      this.blockln('{}')
      this.writeln(`type DataType = ${node.id!}`)
      this.popln()
      this.writeln()
    }
  }

  renderTypeNamespace(node: SemanticTypeNode) {
    this.renderTypeNamespaceFor(node.id!, node.getDefinition())
  }

  private renderTypeNamespaceFor(name: string, inputDef?: SemanticNode) {
    this.write(`declare namespace ${name} `)
    this.blockln('{}')
    let typeDef = 'TAtscriptTypeDef'
    if (inputDef) {
      let realDef = inputDef
      if (isRef(inputDef)) {
        realDef = this.doc.unwindType(inputDef.id!, inputDef.chain)?.def || realDef
      }
      realDef = this.doc.mergeIntersection(realDef)
      if (isStructure(realDef) || isInterface(realDef)) {
        typeDef = `TAtscriptTypeObject<keyof ${name}, ${name}>`
      } else if (isGroup(realDef)) {
        typeDef = `TAtscriptTypeComplex<${name}>`
      } else if (isArray(realDef)) {
        typeDef = `TAtscriptTypeArray<${name}>`
      } else if (isPrimitive(realDef)) {
        typeDef = `TAtscriptTypeFinal<${name}>`
      }
    }
    this.writeln(`type DataType = ${name}`)
    this.writeln(`const __is_atscript_annotated_type: true`)
    this.writeln(`const type: ${typeDef}`)
    this.writeln(`const metadata: TMetadataMap<AtscriptMetadata>`)
    this.writeln(
      `const validator: (opts?: Partial<TValidatorOptions>) => Validator<TAtscriptAnnotatedType, ${name}>`
    )
    if (resolveJsonSchemaMode(this.opts) === false) {
      this.writeln("/** @deprecated JSON Schema support is disabled. Calling this method will throw a runtime error. To enable, set `jsonSchema: 'lazy'` or `jsonSchema: 'bundle'` in tsPlugin options, or add `@emit.jsonSchema` annotation to individual interfaces. */")
    }
    this.writeln('const toJsonSchema: () => any')
    this.popln()
  }

  private isTypeTarget(name: string, doc?: AtscriptDoc): boolean {
    const d = doc || this.doc
    const decl = d.getDeclarationOwnerNode(name)
    if (!decl?.node) return false
    if (decl.node.entity === 'type') return true
    if (decl.node.entity === 'interface') return false
    if (decl.node.entity === 'annotate') {
      return this.isTypeTarget((decl.node as SemanticAnnotateNode).targetName, decl.doc)
    }
    return false
  }

  renderJsDoc(node: SemanticNode) {
    const range = node.token('identifier')?.range
    const rangeStr = range ? `:${range.start.line + 1}:${range.start.character + 1}` : ''
    this.writeln(`/**`)
    this.writeln(` * Atscript ${node.entity} **${node.id!}**`)
    this.writeln(` * @see {@link ./${this.doc.name}${rangeStr}}`)
    this.writeln(` */`)
  }
}

function renderPrimitiveTypeDef(def?: TPrimitiveTypeDef): string {
  if (!def) {
    return 'unknown'
  }
  // If it's a direct final type, return it
  if (typeof def === 'string') {
    return def === 'void' ? 'undefined' : def
  }

  switch (def.kind) {
    case 'final':
      return def.value === 'void' ? 'undefined' : def.value
    case 'union':
      return def.items.map(renderPrimitiveTypeDef).join(' | ')
    case 'intersection':
      return def.items.map(renderPrimitiveTypeDef).join(' & ')
    case 'tuple':
      return `[${def.items.map(renderPrimitiveTypeDef).join(', ')}]`
    case 'array':
      return `${renderPrimitiveTypeDef(def.of)}[]`
    case 'object': {
      const props = Object.entries(def.props)
        .map(
          ([key, val]) =>
            `${wrapProp(key)}${
              typeof val === 'object' && val.optional ? '?' : ''
            }: ${renderPrimitiveTypeDef(val)}`
        )
        .join('; ')
      return `{ ${props} }`
    }
    default:
      // Fallback in case of unexpected input
      return 'unknown'
  }
}
