import {
  isArray,
  isConst,
  isGroup,
  isPrimitive,
  isRef,
  isStructure,
  SemanticArrayNode,
  SemanticInterfaceNode,
  SemanticNode,
  SemanticRefNode,
  SemanticStructureNode,
  SemanticTypeNode,
} from '@anscript/core'
import { BaseRenderer } from './base-renderer'
import { escapeQuotes, wrapProp } from './utils'

export class TypeRenderer extends BaseRenderer {
  pre() {
    this.writeln('// prettier-ignore-start')
    this.writeln('/* eslint-disable */')
    this.writeln('/**')
    this.writeln(` * ðŸª„ This file was generated by Anscript from "${this.doc.name}"`)
    this.writeln(' * Do not edit this file!')
    this.writeln(' */')
  }

  post() {
    this.writeln('// prettier-ignore-end')
  }

  renderTypeDef(def?: SemanticNode) {
    if (!def) {
      this.write('unknown')
      return
    }
    if (isStructure(def)) {
      return this.renderStructure(def)
    }
    if (isGroup(def)) {
      const tuple = def.entity === 'tuple'
      const operator = tuple ? ', ' : ` ${def.op!} `
      const children = def.unwrap()
      const hasSubgroup = !tuple && children.some(c => c.entity === 'group')
      this.write(tuple ? '[' : hasSubgroup ? '(' : '')
      this.renderTypeDef(def.first)
      for (const child of children.slice(1)) {
        this.write(operator)
        this.renderTypeDef(child)
      }
      return this.write(tuple ? ']' : hasSubgroup ? ')' : '')
    }
    if (isConst(def)) {
      const name =
        def.token('identifier')?.type === 'number' ? def.id! : `"${escapeQuotes(def.id!)}"`
      return this.write(name)
    }
    if (isRef(def)) {
      const node = def as SemanticRefNode
      const target = this.doc.getDeclarationOwnerNode(node.id!)?.node
      if (isPrimitive(target)) {
        return this.write(target.config?.nativeTypes?.typescript ?? 'unknown')
      }
      let name = node.id!
      for (const c of node.chain) {
        name += `["${escapeQuotes(c.text)}"]`
      }
      return this.write(name)
    }
    if (isArray(def)) {
      const node = def as SemanticArrayNode
      const def2 = node.getDefinition()
      const isGrp = def2?.entity === 'group'
      if (isGrp) {
        this.write('(')
      }
      this.renderTypeDef(def2)
      if (isGrp) {
        this.write(')')
      }
      return this.write('[]')
    }
  }

  renderStructure(struct: SemanticStructureNode) {
    this.blockln('{}')
    for (const prop of Array.from(struct.props.values())) {
      const optional = !!prop.token('optional')
      this.write(wrapProp(prop.id!), optional ? '?' : '', ': ')
      this.renderTypeDef(prop.getDefinition())
      this.writeln()
    }
    this.pop()
  }

  renderInterface(node: SemanticInterfaceNode) {
    this.writeln()
    const exported = node.token('export')?.text === 'export'
    this.write(exported ? 'export declare ' : 'declare ')
    this.write(`class ${node.id!} `)
    const struct = node.getDefinition()
    if (struct?.entity === 'structure') {
      this.renderStructure(struct as SemanticStructureNode)
    } else {
      this.writeln('{}')
    }
    this.writeln()
  }

  renderType(node: SemanticTypeNode) {
    this.writeln()
    const exported = node.token('export')?.text === 'export'
    this.write(exported ? 'export ' : 'declare ')
    this.write(`type ${node.id!} = `)
    this.renderTypeDef(node.getDefinition())
    this.writeln()
  }
}
