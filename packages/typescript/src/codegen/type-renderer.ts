import {
  isArray,
  isConst,
  isGroup,
  isPrimitive,
  isRef,
  isStructure,
  SemanticArrayNode,
  SemanticInterfaceNode,
  SemanticNode,
  SemanticRefNode,
  SemanticStructureNode,
  SemanticTypeNode,
} from '@anscript/core'
import { BaseRenderer } from './base-renderer'
import { escapeQuotes, wrapProp } from './utils'

export class TypeRenderer extends BaseRenderer {
  pre() {
    this.writeln(`/// <reference path="./${this.doc.name}" />`)
    this.writeln('// prettier-ignore-start')
    this.writeln('/* eslint-disable */')
    this.writeln('/**')
    this.writeln(' * ðŸª„ This file was generated by Anscript')
    this.writeln(' * Do not edit this file!')
    this.writeln(' */')
    this.writeln()
    this.writeln('import type { TAnscriptTypeObject, TMetadataMap } from "@anscript/typescript"')
  }

  post() {
    this.writeln('// prettier-ignore-end')
  }

  renderTypeDef(def?: SemanticNode) {
    if (!def) {
      this.write('unknown')
      return
    }
    if (isStructure(def)) {
      return this.renderStructure(def)
    }
    if (isGroup(def)) {
      const tuple = def.entity === 'tuple'
      const operator = tuple ? ', ' : ` ${def.op!} `
      const children = def.unwrap()
      const hasSubgroup = !tuple && children.some(c => c.entity === 'group')
      this.write(tuple ? '[' : hasSubgroup ? '(' : '')
      this.renderTypeDef(def.first)
      for (const child of children.slice(1)) {
        this.write(operator)
        this.renderTypeDef(child)
      }
      return this.write(tuple ? ']' : hasSubgroup ? ')' : '')
    }
    if (isConst(def)) {
      const name =
        def.token('identifier')?.type === 'number' ? def.id! : `"${escapeQuotes(def.id!)}"`
      return this.write(name)
    }
    if (isRef(def)) {
      const node = def as SemanticRefNode
      const target = this.doc.getDeclarationOwnerNode(node.id!)?.node
      if (isPrimitive(target)) {
        return this.write(target.config?.nativeTypes?.typescript ?? 'unknown')
      }
      let name = node.id!
      for (const c of node.chain) {
        name += `["${escapeQuotes(c.text)}"]`
      }
      return this.write(name)
    }
    if (isArray(def)) {
      const node = def as SemanticArrayNode
      const def2 = node.getDefinition()
      const isGrp = def2?.entity === 'group'
      if (isGrp) {
        this.write('(')
      }
      this.renderTypeDef(def2)
      if (isGrp) {
        this.write(')')
      }
      return this.write('[]')
    }
  }

  renderStructure(struct: SemanticStructureNode, asClass?: string) {
    this.blockln('{}')
    // let propsList = ''
    for (const prop of Array.from(struct.props.values())) {
      // propsList += (propsList ? ' | ' : '') + `"${escapeQuotes(prop.id!)}"`
      const optional = !!prop.token('optional')
      this.write(wrapProp(prop.id!), optional ? '?' : '', ': ')
      this.renderTypeDef(prop.getDefinition())
      this.writeln()
    }
    if (asClass) {
      this.writeln('static __is_anscript_annotated_type: boolean')
      this.writeln(`static type: TAnscriptTypeObject<keyof ${asClass}>`)
      this.writeln(`static metadata: TMetadataMap<AnscriptMetadata>`)
    }
    this.pop()
  }

  renderInterface(node: SemanticInterfaceNode) {
    this.writeln()
    const exported = node.token('export')?.text === 'export'
    this.renderJsDoc(node)
    this.write(exported ? 'export declare ' : 'declare ')
    this.write(`class ${node.id!} `)
    const struct = node.getDefinition()
    if (struct?.entity === 'structure') {
      this.renderStructure(struct as SemanticStructureNode, node.id!)
    } else {
      this.writeln('{}')
    }
    this.writeln()
  }

  renderType(node: SemanticTypeNode) {
    this.writeln()
    const exported = node.token('export')?.text === 'export'
    this.renderJsDoc(node)
    this.write(exported ? 'export ' : 'declare ')
    this.write(`type ${node.id!} = `)
    this.renderTypeDef(node.getDefinition())
    this.writeln()
  }

  renderJsDoc(node: SemanticNode) {
    const range = node.token('identifier')?.range
    const rangeStr = range ? `:${range.start.line + 1}:${range.start.character + 1}` : ''
    this.writeln(`/**`)
    this.writeln(` * Anscript ${node.entity} **${node.id!}**`)
    this.writeln(` * @see {@link ./${this.doc.name}${rangeStr}}`)
    this.writeln(` */`)
  }
}
