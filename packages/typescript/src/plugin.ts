import {
  AnscriptDoc,
  SemanticArrayNode,
  SemanticImportNode,
  SemanticInterfaceNode,
  SemanticNode,
  SemanticRefNode,
  SemanticTypeNode,
  TAnscriptPlugin,
  TAnscriptRenderContext,
  isArray,
  isConst,
  isGroup,
  isImport,
  isInterface,
  isPrimitive,
  isRef,
  isStructure,
  isTuple,
  isType,
} from '@anscript/core'
import { TsArtifact } from './ts-gen/ts-artifact'
import { TsStructure } from './ts-gen/ts-structure'
import { TsClass } from './ts-gen/ts-class'
import { TsProperty } from './ts-gen/ts-prop'
import { TsType } from './ts-gen/ts-type'
import { TsTuple } from './ts-gen/ts-tuple'
import { TsTypeAlias } from './ts-gen/ts-type-alias'
import { TsImport } from './ts-gen/ts-import'
import { genAnnotations, annotateProps } from './annotate-props'
import { escapeQuotes } from './ts-gen/utils'
import { TsObject } from './ts-gen/ts-object'

export const tsPlugin: () => TAnscriptPlugin = () => {
  return {
    name: 'typesccript',
    render(doc, context) {
      return [
        {
          name: context === 'prepare' ? `${doc.name}.d.ts` : `${doc.name}.ts`,
          content:
            '// prettier-ignore-start\n' +
            '/* eslint-disable */\n' +
            '/**\n' +
            ` * ðŸª„ This file was generated by Anscript from "${doc.name}.as".\n` +
            ' * Do not edit this file!\n' +
            '*/\n' +
            renderDocument(doc, context) +
            '\n// prettier-ignore-end\n',
        },
      ]
    },
  } as TAnscriptPlugin
}

function renderDocument(doc: AnscriptDoc, context: TAnscriptRenderContext): string {
  const tsArtifacts = [
    new TsImport('@anscript/typescript/runtime')
      .addNamed('defineAnnotatedType')
      .addNamed('type TAnscriptTypeObject'),
  ] as TsArtifact[]
  const unused = new Set(doc.getUnusedTokens().map(t => t.text))
  for (const n of doc.nodes) {
    if (isInterface(n)) {
      const node = n as SemanticInterfaceNode
      if (unused.has(node.id!)) {
        // skip unused interfaces
        continue
      }
      const interfaceName = node.id!
      // const exported = !!node.token('export')
      // if (exported) {
      tsArtifacts.push(createClass(doc, interfaceName, node))
      if (context !== 'prepare') {
        tsArtifacts.push(annotateProps(doc, interfaceName, node))
      }
      // } else {
      //   tsArtifacts.push(createInterface(interfaceName, node))
      // }
      continue
    }
    if (isType(n)) {
      const node = n as SemanticTypeNode
      if (unused.has(node.id!)) {
        // skip unused types
        continue
      }
      tsArtifacts.push(createTypeAlias(doc, node.id!, node))
      continue
    }
    if (isImport(n)) {
      const node = n as SemanticImportNode
      const t = createImport(node, unused)
      if (t) {
        tsArtifacts.push(t)
      }
    }
  }
  return tsArtifacts.map(a => (context === 'prepare' ? a.renderTypes() : a.render())).join('')
}

function createImport(node: SemanticImportNode, unused: Set<string>): TsImport | undefined {
  const t = new TsImport(node.token('path')!.text)
  const def = node.getDefinition()
  let isUnusedImport = true
  if (isGroup(def)) {
    for (const child of def.unwrap()) {
      if (isRef(child) && !unused.has(child.id!)) {
        const node = child as SemanticRefNode
        t.addNamed(node.id!)
        isUnusedImport = false
      }
    }
  }

  if (isRef(def) && !unused.has(def.id!)) {
    const node = def as SemanticRefNode
    t.addNamed(node.id!)
    isUnusedImport = false
  }
  return isUnusedImport ? undefined : t
}

function createTypeAlias(doc: AnscriptDoc, name: string, node: SemanticTypeNode) {
  const exported = !!node.token('export')
  const t = new TsTypeAlias(name, createType(doc, node.getDefinition()!))
  if (exported) {
    t.exportAs('named')
  }
  return t
}

// function createInterface(name: string, node: SemanticInterfaceNode): TsInterface {
//   const exported = !!node.token('export')

//   const a = new TsInterface(name, createStructure(node.getDefinition()))
//   if (exported) {
//     a.exportAs('named')
//   }

//   return a
// }

function createStructure(doc: AnscriptDoc, node?: SemanticNode): TsStructure {
  const s = new TsStructure()
  if (isStructure(node)) {
    for (const prop of Array.from(node.props.values())) {
      const optional = !!prop.token('optional')
      const def = prop.getDefinition()
      if (def) {
        s.addProp(prop.id!, createType(doc, def), optional)
      }
    }
  }
  return s
}

function createType(doc: AnscriptDoc, n: SemanticNode): TsType {
  if (isStructure(n)) {
    return createStructure(doc, n)
  }
  if (isTuple(n)) {
    const tuple = new TsTuple()
    for (const child of n.unwrap()) {
      tuple.addItem(createType(doc, child))
    }
    return tuple
  }
  if (isGroup(n)) {
    const operator = n.op
    const firstNode = n.first
    const s = createType(doc, firstNode)
    for (const child of n.unwrap().slice(1)) {
      if (operator === '|') {
        s.union(createType(doc, child))
      } else {
        s.intersection(createType(doc, child))
      }
    }
    return s
  }
  if (isConst(n)) {
    const name = n.token('identifier')?.type === 'number' ? n.id! : `"${escapeQuotes(n.id!)}"`
    return new TsType(name)
  }
  if (isRef(n)) {
    const node = n as SemanticRefNode
    const target = doc.getDeclarationOwnerNode(node.id!)?.node
    if (isPrimitive(target)) {
      return new TsType(target.config?.nativeTypes?.typescript ?? 'unknown')
    }
    let name = node.id!
    for (const c of node.chain) {
      name += `["${escapeQuotes(c.text)}"]`
    }
    return new TsType(name)
  }
  if (isArray(n)) {
    const node = n as SemanticArrayNode
    const type = createType(doc, node.getDefinition()!)
    type.array()
    return type
  }
  throw new Error(`Could not create type: unsupported node ${(n as SemanticNode).toString()}`)
}

function createClass(doc: AnscriptDoc, name: string, node: SemanticInterfaceNode): TsClass {
  const exported = !!node.token('export')

  const a = new TsClass(name)
  if (exported) {
    a.exportAs('named')
  }
  const struct = node.getDefinition()
  if (isStructure(struct)) {
    for (const prop of Array.from(struct.props.values())) {
      const optional = !!prop.token('optional')
      const type = createType(doc, prop.getDefinition()!)
      const p = new TsProperty(prop.id!, type)
      if (optional) {
        p.optional()
      }
      a.addProp(p)
    }
  }
  a.addProp(new TsProperty('__is_anscript_annotated_type', 'boolean', 'true').static())
  const typeObj = new TsObject()
    .addEntry('kind', '"object"')
    .addEntry('type', name)
    .addEntry('props', 'new Map()')
  a.addProp(new TsProperty('type', 'TAnscriptTypeObject', typeObj.render()).static().forceType())
  a.addProp(new TsProperty('metadata', 'any', genAnnotations(node).render()).static())

  return a
}
