import {
  AnscriptDoc,
  SemanticArrayNode,
  SemanticImportNode,
  SemanticInterfaceNode,
  SemanticNode,
  SemanticRefNode,
  SemanticTypeNode,
  TAnscriptPlugin,
  TAnscriptRenderContext,
  isArray,
  isConst,
  isGroup,
  isImport,
  isInterface,
  isRef,
  isStructure,
  isTuple,
  isType,
} from '@anscript/core'
import { TsArtifact } from './ts-gen/ts-artifact'
import { TsInterface } from './ts-gen/ts-interface'
import { TsStructure } from './ts-gen/ts-structure'
import { TsClass } from './ts-gen/ts-class'
import { TsProperty } from './ts-gen/ts-prop'
import { TsMethod } from './ts-gen/ts-method'
import { TsType } from './ts-gen/ts-type'
import { TsTuple } from './ts-gen/ts-tuple'
import { TsTypeAlias } from './ts-gen/ts-type-alias'
import { TsImport } from './ts-gen/ts-import'

export const tsPlugin: () => TAnscriptPlugin = () => {
  return {
    name: 'typesccript',
    render(doc, context) {
      return [
        {
          name: context === 'prepare' ? `${doc.name}.d.ts` : `${doc.name}.ts`,
          content:
            '// prettier-ignore-start\n' +
            '/* eslint-disable */\n' +
            '/**\n' +
            ` * ðŸª„ This file was generated by Anscript from "${doc.name}.as".\n` +
            ' * Do not edit this file!\n' +
            '*/\n' +
            renderDocument(doc, context) +
            '\n// prettier-ignore-end\n',
        },
      ]
    },
  } as TAnscriptPlugin
}

function renderDocument(doc: AnscriptDoc, context: TAnscriptRenderContext): string {
  const tsArtifacts = [] as TsArtifact[]
  const unused = new Set(doc.getUnusedTokens().map(t => t.text))
  for (const n of doc.nodes) {
    if (isInterface(n)) {
      const node = n as SemanticInterfaceNode
      if (unused.has(node.id!)) {
        // skip unused interfaces
        continue
      }
      const interfaceName = node.id!
      const exported = !!node.token('export')
      if (exported) {
        tsArtifacts.push(createClass(interfaceName, node))
      } else {
        tsArtifacts.push(createInterface(interfaceName, node))
      }
      continue
    }
    if (isType(n)) {
      const node = n as SemanticTypeNode
      if (unused.has(node.id!)) {
        // skip unused types
        continue
      }
      tsArtifacts.push(createTypeAlias(node.id!, node))
      continue
    }
    if (isImport(n)) {
      const node = n as SemanticImportNode
      const t = createImport(node, unused)
      if (t) {
        tsArtifacts.push(t)
      }
    }
  }
  return tsArtifacts.map(a => (context === 'prepare' ? a.renderTypes() : a.render())).join('')
}

function createImport(node: SemanticImportNode, unused: Set<string>): TsImport | undefined {
  const t = new TsImport(node.token('path')!.text)
  const def = node.getDefinition()
  let isUnusedImport = true
  if (isGroup(def)) {
    for (const child of def.unwrap()) {
      if (isRef(child) && !unused.has(child.id!)) {
        const node = child as SemanticRefNode
        t.addNamed(node.id!)
        isUnusedImport = false
      }
    }
  }

  if (isRef(def) && !unused.has(def.id!)) {
    const node = def as SemanticRefNode
    t.addNamed(node.id!)
    isUnusedImport = false
  }
  return isUnusedImport ? undefined : t
}

function createTypeAlias(name: string, node: SemanticTypeNode) {
  const exported = !!node.token('export')
  const t = new TsTypeAlias(name, createType(node.getDefinition()!))
  if (exported) {
    t.exportAs('named')
  }
  return t
}

function createInterface(name: string, node: SemanticInterfaceNode): TsInterface {
  const exported = !!node.token('export')

  const a = new TsInterface(name, createStructure(node.getDefinition()))
  if (exported) {
    a.exportAs('named')
  }

  return a
}

function createStructure(node?: SemanticNode): TsStructure {
  const s = new TsStructure()
  if (isStructure(node)) {
    for (const prop of Array.from(node.props.values())) {
      const optional = !!prop.token('optional')
      const def = prop.getDefinition()
      if (def) {
        s.addProp(prop.id!, createType(def), optional)
      }
    }
  }
  return s
}

function createType(n: SemanticNode): TsType {
  if (isStructure(n)) {
    return createStructure(n)
  }
  if (isTuple(n)) {
    const tuple = new TsTuple()
    for (const child of n.unwrap()) {
      tuple.addItem(createType(child))
    }
    return tuple
  }
  if (isGroup(n)) {
    const operator = n.op
    const firstNode = n.first
    const s = createType(firstNode)
    for (const child of n.unwrap().slice(1)) {
      if (operator === '|') {
        s.union(createType(child))
      } else {
        s.intersection(createType(child))
      }
    }
    return s
  }
  if (isConst(n)) {
    const name =
      n.token('identifier')?.type === 'number' ? n.id! : `"${n.id!.replace(/"/g, '\\"')}"`
    return new TsType(name)
  }
  if (isRef(n)) {
    const node = n as SemanticRefNode
    let name = node.id!
    for (const c of node.chain) {
      name += `["${c.text.replace(/"/g, '\\"')}"]`
    }
    return new TsType(name)
  }
  if (isArray(n)) {
    const node = n as SemanticArrayNode
    const type = createType(node.getDefinition()!)
    type.array()
    return type
  }
  throw new Error(`Could not create type: unsupported node ${(n as SemanticNode).toString()}`)
}

function createClass(name: string, node: SemanticInterfaceNode): TsClass {
  const exported = !!node.token('export')

  const a = new TsClass(name)
  if (exported) {
    a.exportAs('named')
  }
  const struct = node.getDefinition()
  if (isStructure(struct)) {
    for (const prop of Array.from(struct.props.values())) {
      const optional = !!prop.token('optional')
      const type = createType(prop.getDefinition()!)
      const p = new TsProperty(prop.id!, type)
      if (optional) {
        p.optional()
      }
      a.addProp(p)
    }
  }
  const m = new TsMethod('static get __anscriptMeta', [], 'any')
  m.addBodyLine('return {}')
  a.addMethod(m)

  return a
}
